#!/bin/bash
# ==============================================================================
# Exitbox Docker Entrypoint
# Runs firewall setup, workspace selection, and executes agent
# ==============================================================================

set -e

WORKSPACE="/workspace"
CODEX_CALLBACK_PORT="1455"
CODEX_RELAY_PORT="2455"
RELAY_PID=""
WORKSPACE_SWITCH_FILE="/workspace/.exitbox/workspace-switch"
SESSION_ACTION_FILE="/workspace/.exitbox/session-action"
GLOBAL_CONFIG_FILE="/home/user/.exitbox-config/config.yaml"
GLOBAL_WORKSPACE_ROOT="/home/user/.exitbox-config/profiles/global"
# Save the workspace that was bind-mounted at container start (for isolation detection).
EXITBOX_MOUNTED_WORKSPACE="${EXITBOX_WORKSPACE_NAME:-}"

agent_display_name() {
    case "$1" in
        claude)   echo "Claude Code" ;;
        codex)    echo "OpenAI Codex" ;;
        opencode) echo "OpenCode" ;;
        *)        echo "$1" ;;
    esac
}

parse_keybindings() {
    KB_WORKSPACE_MENU="C-M-p"
    KB_SESSION_MENU="C-M-s"
    if [[ -n "${EXITBOX_KEYBINDINGS:-}" ]]; then
        IFS=',' read -ra KB_PAIRS <<< "$EXITBOX_KEYBINDINGS"
        for pair in "${KB_PAIRS[@]}"; do
            key="${pair%%=*}"
            val="${pair#*=}"
            case "$key" in
                workspace_menu) KB_WORKSPACE_MENU="$val" ;;
                session_menu)   KB_SESSION_MENU="$val" ;;
            esac
        done
    fi
}

parse_keybindings

update_tmux_status() {
    local display ws_name ver session_name
    display="$(agent_display_name "$AGENT")"
    ws_name="${EXITBOX_WORKSPACE_NAME:-default}"
    ver="${EXITBOX_VERSION:-dev}"
    session_name="${EXITBOX_SESSION_NAME:-default}"
    tmux set -g status-left " ExitBox  ${display} " 2>/dev/null || true
    tmux set -g window-status-current-format " Workspace: ${ws_name} | Session: ${session_name} " 2>/dev/null || true
    tmux set -g status-right " ${ver}  ${KB_WORKSPACE_MENU}: workspaces  ${KB_SESSION_MENU}: sessions " 2>/dev/null || true
}

write_tmux_conf() {
    local conf="/tmp/exitbox-tmux.conf"
    local display ws_name ver session_name
    display="$(agent_display_name "$AGENT")"
    ws_name="${EXITBOX_WORKSPACE_NAME:-default}"
    ver="${EXITBOX_VERSION:-dev}"
    session_name="${EXITBOX_SESSION_NAME:-default}"

    cat > "$conf" <<TMUXEOF
# ExitBox tmux configuration
set -g default-terminal "xterm-256color"
set -g status-position top
set -g status-style "bg=colour236,fg=colour255"
set -g status-left " ExitBox  ${display} "
set -g status-left-length 80
set -g status-right " ${ver}  ${KB_WORKSPACE_MENU}: workspaces  ${KB_SESSION_MENU}: sessions "
set -g status-right-length 90
set -g status-justify centre
set -g window-status-format ""
set -g window-status-current-format " Workspace: ${ws_name} | Session: ${session_name} "
set -g mouse on
set -g history-limit 100000
set -g aggressive-resize on
set -g window-size latest
set -g pane-border-style "fg=colour236"
set -g pane-active-border-style "fg=colour236"
set -g message-style "bg=colour236,fg=colour255"
set -g allow-passthrough on
TMUXEOF

    if [[ "${EXITBOX_STATUS_BAR:-true}" != "true" ]]; then
        echo "set -g status off" >> "$conf"
    fi
    echo "$conf"
}

cleanup_relay() {
    if [[ -n "$RELAY_PID" ]]; then
        kill "$RELAY_PID" >/dev/null 2>&1 || true
    fi
}

start_codex_callback_relay() {
    if ! command -v socat >/dev/null 2>&1; then
        echo "[WARN] socat not found; Codex OAuth callback relay disabled" >&2
        return 0
    fi

    # Relay container-reachable traffic on 2455 to Codex's localhost callback on 1455.
    socat "TCP-LISTEN:${CODEX_RELAY_PORT},bind=0.0.0.0,reuseaddr,fork" "TCP:127.0.0.1:${CODEX_CALLBACK_PORT}" >/tmp/codex-oauth-relay.log 2>&1 &
    RELAY_PID="$!"
}

IDE_RELAY_PID=""

start_ide_relay() {
    [[ "$AGENT" != "claude" ]] && return
    [[ "${ENABLE_IDE_INTEGRATION:-}" != "true" ]] && return
    [[ -z "${EXITBOX_IDE_PORT:-}" ]] && return
    command -v socat >/dev/null 2>&1 || return 0

    local port="${EXITBOX_IDE_PORT}" sock="/run/exitbox/ide.sock" retries=0
    while [[ ! -S "$sock" ]] && [[ $retries -lt 20 ]]; do sleep 0.1; ((retries++)); done
    [[ -S "$sock" ]] || return 0

    socat "TCP-LISTEN:${port},bind=127.0.0.1,reuseaddr,fork" \
          "UNIX-CONNECT:${sock}" >/tmp/ide-relay.log 2>&1 &
    IDE_RELAY_PID="$!"
}

cleanup_ide_relay() {
    [[ -n "$IDE_RELAY_PID" ]] && kill "$IDE_RELAY_PID" >/dev/null 2>&1 || true
}

ensure_workspace_files() {
    mkdir -p "$(dirname "$GLOBAL_CONFIG_FILE")"
    mkdir -p "$GLOBAL_WORKSPACE_ROOT"
    if [[ ! -f "$GLOBAL_CONFIG_FILE" ]]; then
        cat > "$GLOBAL_CONFIG_FILE" <<'EOF'
version: 1
workspaces:
  active: default
  items:
    - name: default
      development: []
agents:
  claude:
    enabled: true
  codex:
    enabled: true
  opencode:
    enabled: true
tools:
  user: []
settings:
  auto_update: false
  status_bar: true
  default_workspace: default
  default_flags:
    no_firewall: false
    read_only: false
    no_env: false
    auto_resume: false
EOF
    fi
}

workspace_entries() {
    local globals
    # Try new key first, fall back to old "profiles" key
    globals="$(yq -r '(.workspaces.items[]?.name // .profiles.items[]?.name) // ""' "$GLOBAL_CONFIG_FILE" 2>/dev/null | sed '/^$/d')"
    if [[ -z "$globals" ]]; then
        globals="$(yq -r '.profiles.items[]?.name // ""' "$GLOBAL_CONFIG_FILE" 2>/dev/null | sed '/^$/d')"
    fi
    local result=""
    while IFS= read -r name; do
        [[ -z "$name" ]] && continue
        # Skip the currently active workspace.
        [[ "$name" == "${EXITBOX_WORKSPACE_NAME:-}" ]] && continue
        local dir
        dir="$(NAME="$name" yq -r '(.workspaces.items[] | select(.name == strenv(NAME)) | .directory) // ""' "$GLOBAL_CONFIG_FILE" 2>/dev/null || true)"
        if [[ -n "$dir" ]]; then
            result="${result}directory:${name} [${dir}]"$'\n'
        else
            result="${result}global:${name}"$'\n'
        fi
    done <<< "$globals"
    printf '%s' "$result" | sed '/^$/d'
}

resolve_active_workspace() {
    local global_default global_active first_global

    # Check directory-scoped workspaces (new key only)
    local current_dir
    current_dir="$(pwd)"
    local dir_match
    dir_match="$(yq -r ".workspaces.items[] | select(.directory == \"${current_dir}\") | .name // \"\"" "$GLOBAL_CONFIG_FILE" 2>/dev/null | head -n1 || true)"
    if [[ -n "$dir_match" ]]; then
        echo "directory:${dir_match}"
        return 0
    fi

    # Try new key, fall back to old key
    global_default="$(yq -r '.settings.default_workspace // .settings.default_profile // ""' "$GLOBAL_CONFIG_FILE" 2>/dev/null || true)"
    if [[ -n "$global_default" ]]; then
        echo "global:${global_default}"
        return 0
    fi

    global_active="$(yq -r '.workspaces.active // .profiles.active // ""' "$GLOBAL_CONFIG_FILE" 2>/dev/null || true)"
    if [[ -n "$global_active" ]]; then
        echo "global:${global_active}"
        return 0
    fi

    first_global="$(yq -r '.workspaces.items[]?.name // ""' "$GLOBAL_CONFIG_FILE" 2>/dev/null | sed '/^$/d' | head -n1)"
    if [[ -z "$first_global" ]]; then
        first_global="$(yq -r '.profiles.items[]?.name // ""' "$GLOBAL_CONFIG_FILE" 2>/dev/null | sed '/^$/d' | head -n1)"
    fi
    if [[ -n "$first_global" ]]; then
        echo "global:${first_global}"
        return 0
    fi

    echo "global:default"
}

set_active_workspace() {
    local scope="$1"
    local name="$2"
    if [[ -z "$scope" || -z "$name" ]]; then
        return 1
    fi

    ensure_workspace_files

    # Write new keys
    NAME="$name" yq -i '.settings.default_workspace = strenv(NAME)' "$GLOBAL_CONFIG_FILE"
    NAME="$name" yq -i '.workspaces.active = strenv(NAME)' "$GLOBAL_CONFIG_FILE"
    # Also write old keys for backward compat with configs not yet migrated
    NAME="$name" yq -i '.settings.default_profile = strenv(NAME)' "$GLOBAL_CONFIG_FILE"
    NAME="$name" yq -i '.profiles.active = strenv(NAME)' "$GLOBAL_CONFIG_FILE"
    return 0
}

link_path() {
    local src="$1"
    local dst="$2"
    mkdir -p "$(dirname "$dst")"
    rm -rf "$dst"
    ln -s "$src" "$dst"
}

apply_active_workspace_links() {
    ensure_workspace_files

    local scope name workspace_root

    # If the Go host already specified a workspace (via --workspace flag or
    # env var), use it directly. Only resolve from config.yaml when unset
    # (e.g. after an in-container workspace switch via Ctrl+Alt+P).
    if [[ -n "${EXITBOX_WORKSPACE_NAME:-}" ]]; then
        scope="${EXITBOX_WORKSPACE_SCOPE:-global}"
        name="${EXITBOX_WORKSPACE_NAME}"
    else
        local resolved
        resolved="$(resolve_active_workspace)"
        scope="${resolved%%:*}"
        name="${resolved#*:}"
    fi

    export EXITBOX_WORKSPACE_SCOPE="$scope"
    export EXITBOX_WORKSPACE_NAME="$name"

    workspace_root="${GLOBAL_WORKSPACE_ROOT}/${name}/${AGENT}"

    # Credential isolation: only the workspace that was mounted at container
    # start has real data. If the user switched to a different workspace via
    # Ctrl+P, its directory is empty (not bind-mounted from host).
    if [[ -n "$EXITBOX_MOUNTED_WORKSPACE" && "$name" != "$EXITBOX_MOUNTED_WORKSPACE" ]]; then
        echo "" >&2
        echo "[NOTE] Switched to workspace '${name}', but this container was started with workspace '${EXITBOX_MOUNTED_WORKSPACE}'." >&2
        echo "[NOTE] Credentials for '${name}' are not available in this session." >&2
        echo "[NOTE] To use this workspace, exit and re-run:" >&2
        echo "[NOTE]   exitbox run --workspace ${name} ${AGENT}" >&2
        echo "" >&2
    fi

    mkdir -p "$workspace_root"

    case "$AGENT" in
        claude)
            mkdir -p "$workspace_root/.claude" "$workspace_root/.config"
            touch "$workspace_root/.claude.json"
            link_path "$workspace_root/.claude" "$HOME/.claude"
            link_path "$workspace_root/.claude.json" "$HOME/.claude.json"
            link_path "$workspace_root/.config" "$HOME/.config"
            ;;
        codex)
            mkdir -p "$workspace_root/.codex" "$workspace_root/.config/codex"
            link_path "$workspace_root/.codex" "$HOME/.codex"
            mkdir -p "$HOME/.config"
            link_path "$workspace_root/.config/codex" "$HOME/.config/codex"
            ;;
        opencode)
            mkdir -p "$workspace_root/.opencode" \
                     "$workspace_root/.config/opencode" \
                     "$workspace_root/.local/share/opencode" \
                     "$workspace_root/.local/state" \
                     "$workspace_root/.cache/opencode"
            link_path "$workspace_root/.opencode" "$HOME/.opencode"
            mkdir -p "$HOME/.config" "$HOME/.local/share" "$HOME/.local" "$HOME/.cache"
            link_path "$workspace_root/.config/opencode" "$HOME/.config/opencode"
            link_path "$workspace_root/.local/share/opencode" "$HOME/.local/share/opencode"
            link_path "$workspace_root/.local/state" "$HOME/.local/state"
            link_path "$workspace_root/.cache/opencode" "$HOME/.cache/opencode"
            ;;
    esac
}

default_session_name() {
    date +"%Y-%m-%d %H:%M:%S"
}

current_session_name() {
    echo "${EXITBOX_SESSION_NAME:-}"
}

effective_session_name() {
    local name
    name="$(current_session_name)"
    if [[ -z "$name" ]]; then
        name="$(default_session_name)"
    fi
    echo "$name"
}

project_resume_dir() {
    local resume_dir project_key
    resume_dir="${GLOBAL_WORKSPACE_ROOT}/${EXITBOX_WORKSPACE_NAME:-default}/${AGENT}"
    if [[ -n "${EXITBOX_PROJECT_KEY:-}" ]]; then
        project_key="${EXITBOX_PROJECT_KEY//[^a-zA-Z0-9._-]/_}"
        resume_dir="${resume_dir}/projects/${project_key}"
    fi
    echo "$resume_dir"
}

active_session_file() {
    echo "$(project_resume_dir)/.active-session"
}

kv_session_prefix() {
    echo "session:${AGENT}:${EXITBOX_PROJECT_KEY:-_}:"
}

set_active_session_name() {
    local name="$1"
    # Write to KV store first.
    if command -v exitbox-kv >/dev/null 2>&1; then
        exitbox-kv set "$(kv_session_prefix).active-session" "$name" 2>/dev/null || true
    fi
    # Filesystem backup.
    local file
    file="$(active_session_file)"
    mkdir -p "$(dirname "$file")"
    printf '%s' "$name" > "$file"
}

get_active_session_name() {
    # Try KV store first.
    if command -v exitbox-kv >/dev/null 2>&1; then
        local kv_val
        kv_val="$(exitbox-kv get "$(kv_session_prefix).active-session" 2>/dev/null)" && {
            echo "$kv_val"
            return
        }
    fi
    # Filesystem fallback.
    local file
    file="$(active_session_file)"
    if [[ -f "$file" ]]; then
        cat "$file"
    fi
}

session_key_for_name() {
    local name="$1"
    local slug hash
    slug="$(printf '%s' "$name" | tr -c 'A-Za-z0-9._-' '_' | sed 's/^_\\+//; s/_\\+$//; s/_\\+/_/g')"
    if [[ -z "$slug" ]]; then
        slug="session"
    fi
    hash="$(printf '%s' "$name" | cksum | awk '{print $1}')"
    echo "${slug}_${hash}"
}

session_dir_for_name() {
    local name="$1"
    local key
    key="$(session_key_for_name "$name")"
    echo "$(project_resume_dir)/sessions/${key}"
}

ensure_named_session_dir() {
    local name="$1"
    local key
    key="$(session_key_for_name "$name")"
    # Write to KV store.
    if command -v exitbox-kv >/dev/null 2>&1; then
        exitbox-kv set "$(kv_session_prefix)${key}:.name" "$name" 2>/dev/null || true
    fi
    # Filesystem backup.
    local session_dir
    session_dir="$(session_dir_for_name "$name")"
    mkdir -p "$session_dir"
    printf '%s' "$name" > "${session_dir}/.name"
}

legacy_resume_file() {
    echo "$(project_resume_dir)/.resume-token"
}

session_entries() {
    # Try KV store first.
    if command -v exitbox-kv >/dev/null 2>&1; then
        local kv_keys kv_names=""
        kv_keys="$(exitbox-kv list "$(kv_session_prefix)" 2>/dev/null)" || kv_keys=""
        if [[ -n "$kv_keys" ]]; then
            while IFS= read -r kv_key; do
                [[ "$kv_key" == *":.name" ]] || continue
                local name
                name="$(exitbox-kv get "$kv_key" 2>/dev/null)" || continue
                [[ -n "$name" ]] && kv_names="${kv_names}${name}"$'\n'
            done <<< "$kv_keys"
            if [[ -n "$kv_names" ]]; then
                echo "$kv_names" | sed '/^$/d' | awk '!seen[$0]++'
                return
            fi
        fi
    fi
    # Filesystem fallback.
    local root
    root="$(project_resume_dir)/sessions"
    [[ -d "$root" ]] || return 0
    for session_dir in "$root"/*; do
        [[ -d "$session_dir" ]] || continue
        if [[ -f "$session_dir/.name" ]]; then
            cat "$session_dir/.name"
        fi
    done | sed '/^$/d' | awk '!seen[$0]++'
}

write_session_action() {
    local workspace="$1"
    local session_name="$2"
    local resume="${3:-true}"
    mkdir -p "$(dirname "$SESSION_ACTION_FILE")"
    {
        if [[ -n "$workspace" ]]; then
            printf 'workspace=%s\n' "$workspace"
        fi
        if [[ -n "$session_name" ]]; then
            printf 'session=%s\n' "$session_name"
        fi
        printf 'resume=%s\n' "$resume"
    } > "$SESSION_ACTION_FILE"
}

request_graceful_switch() {
    if [[ -n "${EXITBOX_PARENT_PANE:-}" ]]; then
        tmux send-keys -t "${EXITBOX_PARENT_PANE}" C-c >/dev/null 2>&1 || true
    fi
}

session_switch_menu() {
    ensure_workspace_files
    local current_session new_session choices choice
    current_session="$(effective_session_name)"
    new_session="$(default_session_name)"

    choices="${choices}${new_session}"$'\t'"new"$'\n'
    while IFS= read -r s; do
        [[ -z "$s" ]] && continue
        if [[ "$s" == "$current_session" ]]; then
            continue
        fi
        choices="${choices}${s}"$'\t'"existing"$'\n'
    done < <(session_entries)

    local header prompt rc target_session kind
    header="Enter: Switch session"
    prompt="Sessions > "

    set +e
    choice="$(printf '%s' "$choices" | sed '/^$/d' | fzf --height=45% --reverse --border --prompt="$prompt" --header="$header" --delimiter=$'\t' --with-nth=1)"
    rc=$?
    set -e
    if [[ $rc -ne 0 || -z "$choice" ]]; then
        exit 0
    fi

    target_session="$(printf '%s' "$choice" | awk -F'\t' '{print $1}')"
    kind="$(printf '%s' "$choice" | awk -F'\t' '{print $2}')"
    if [[ -z "$target_session" ]]; then
        exit 0
    fi
    if [[ "$kind" == "existing" && "$target_session" == "$current_session" ]]; then
        exit 0
    fi

    write_session_action "" "$target_session" "true"
    echo "Saving current session and switching to session '${target_session}'..."
    request_graceful_switch
    exit 0
}

workspace_switch_menu() {
    ensure_workspace_files
    local current_session choices choice
    current_session="$(effective_session_name)"

    while IFS= read -r w; do
        [[ -z "$w" ]] && continue
        choices="${choices}${w}"$'\n'
    done < <(workspace_entries)
    if [[ -z "$choices" ]]; then
        choices="workspace:none"
    fi

    local header prompt rc
    header="Enter: Switch workspace"
    prompt="Workspaces > "

    set +e
    choice="$(printf '%s' "$choices" | sed '/^$/d' | fzf --height=45% --reverse --border --prompt="$prompt" --header="$header")"
    rc=$?
    set -e
    if [[ $rc -ne 0 || -z "$choice" ]]; then
        exit 0
    fi

    if [[ "$choice" == "workspace:none" ]]; then
        exit 0
    fi

    local workspace_choice scope name
    workspace_choice="$choice"
    scope="${workspace_choice%%:*}"
    name="${workspace_choice#*:}"
    name="${name%% \[*}"
    if [[ "$name" == "${EXITBOX_WORKSPACE_NAME:-}" ]]; then
        exit 0
    fi

    set_active_workspace "$scope" "$name"
    write_session_action "$name" "$current_session" "true"
    echo "Saving current session and switching to workspace '${name}'..."
    request_graceful_switch
    exit 0
}

smart_switch_menu() {
    # Backward-compatible alias: open sessions menu.
    session_switch_menu
}

capture_resume_token() {
    # Always capture tokens so they are available for explicit resume later.
    local output
    output="$(tmux capture-pane -p -S -100 2>/dev/null || true)"
    local session_name token session_dir token_file
    session_name="$(effective_session_name)"
    ensure_named_session_dir "$session_name"
    set_active_session_name "$session_name"
    session_dir="$(session_dir_for_name "$session_name")"
    token_file="${session_dir}/.resume-token"

    local token=""
    case "$AGENT" in
        claude)
            # Match: claude --resume <token>  or  claude -r <token>
            if [[ -n "$output" ]]; then
                token="$(echo "$output" | grep -oE "${AGENT} (--resume|-r) [^ ]+" | tail -1 | awk '{print $NF}' || true)"
            fi
            ;;
        codex)
            # Codex auto-saves sessions to ~/.codex/sessions/; no token printed at exit
            token="last"
            ;;
        opencode)
            # OpenCode auto-saves sessions locally; no token printed at exit
            token="last"
            ;;
    esac

    if [[ -n "$token" ]]; then
        local key
        key="$(session_key_for_name "$session_name")"
        # Write to KV store.
        if command -v exitbox-kv >/dev/null 2>&1; then
            exitbox-kv set "$(kv_session_prefix)${key}:.resume-token" "$token" 2>/dev/null || true
        fi
        # Filesystem backup.
        echo "$token" > "$token_file"
        # Keep a single-slot token as compatibility fallback for older logic.
        echo "$token" > "$(legacy_resume_file)"
    fi
}

build_resume_args() {
    # Session resume resolution (called from run_agent_loop):
    #
    # Priority order:
    #   1. Explicit token (EXITBOX_RESUME_TOKEN set) → use it directly.
    #   2. Auto-resume enabled (EXITBOX_AUTO_RESUME=true):
    #      a. EXITBOX_SESSION_NAME set → look up per-session .resume-token.
    #      b. EXITBOX_SESSION_NAME empty → load from .active-session, then
    #         look up per-session token with legacy single-slot fallback.
    #   3. Neither → no resume args, agent starts fresh.
    #
    # The legacy fallback (project-level .resume-token) is ONLY used when
    # the session name came from .active-session (backward compat for
    # pre-named-session data). Explicitly named sessions that have no
    # stored token are new and always start fresh.
    RESUME_ARGS=()
    local session_name session_dir session_file token legacy_file
    session_name="$(current_session_name)"

    # If an explicit token was passed via --resume <token>, use it directly.
    if [[ -n "${EXITBOX_RESUME_TOKEN:-}" ]]; then
        if [[ -z "$session_name" ]]; then
            session_name="$(effective_session_name)"
        fi
        ensure_named_session_dir "$session_name"
        set_active_session_name "$session_name"
        case "$AGENT" in
            claude)
                RESUME_ARGS=("--resume" "$EXITBOX_RESUME_TOKEN")
                ;;
            codex)
                RESUME_ARGS=("resume" "--last")
                ;;
            opencode)
                RESUME_ARGS=("--continue")
                ;;
        esac
        return
    fi

    # Without explicit token, only auto-resume if enabled (--resume flag or workspace switch).
    if [[ "${EXITBOX_AUTO_RESUME:-false}" != "true" ]]; then
        return
    fi

    # Track whether the session name was explicitly provided (via --name) or
    # loaded from .active-session. The legacy fallback should only apply in
    # the .active-session case — explicitly named new sessions must start fresh.
    local from_active=false
    if [[ -z "$session_name" ]]; then
        session_name="$(get_active_session_name)"
        if [[ -z "$session_name" ]]; then
            return
        fi
        EXITBOX_SESSION_NAME="$session_name"
        from_active=true
    fi

    ensure_named_session_dir "$session_name"
    set_active_session_name "$session_name"

    session_dir="$(session_dir_for_name "$session_name")"
    session_file="${session_dir}/.resume-token"
    token=""
    # Try KV store first.
    local session_key
    session_key="$(session_key_for_name "$session_name")"
    if command -v exitbox-kv >/dev/null 2>&1; then
        token="$(exitbox-kv get "$(kv_session_prefix)${session_key}:.resume-token" 2>/dev/null)" || token=""
    fi
    # Filesystem fallback.
    if [[ -z "$token" && -f "$session_file" ]]; then
        token="$(cat "$session_file")"
    fi

    if [[ -z "$token" && "$from_active" == "true" ]]; then
        # Compatibility fallback for older single-slot sessions that predate
        # the per-session token storage. Only used when resuming via
        # .active-session (no explicit --name). Named sessions that have no
        # saved token are new and should start fresh.
        legacy_file="$(legacy_resume_file)"
        if [[ -f "$legacy_file" ]]; then
            token="$(cat "$legacy_file")"
            if [[ -n "$token" ]]; then
                echo "$token" > "$session_file"
            fi
        fi
    fi

    if [[ -n "$token" ]]; then
        case "$AGENT" in
            claude)
                RESUME_ARGS=("--resume" "$token")
                ;;
            codex)
                RESUME_ARGS=("resume" "--last")
                ;;
            opencode)
                RESUME_ARGS=("--continue")
                ;;
        esac
    fi
}

run_agent_once() {
    if [[ $# -gt 0 ]]; then
        case "$1" in
            claude|codex|opencode)
                exec "$@"
                ;;
            *)
                if [[ -n "$AGENT" ]]; then
                    exec "$AGENT" "$@"
                else
                    exec "$@"
                fi
                ;;
        esac
    else
        if [[ -n "$AGENT" ]]; then
            exec "$AGENT"
        else
            exec bash
        fi
    fi
}

run_agent_loop() {
    apply_active_workspace_links
    update_tmux_status
    if [[ -n "$AGENT" ]]; then
        inject_sandbox_instructions
    fi

    build_resume_args

    # Check if user already passed resume-related flags in their args
    local user_has_resume=false
    for arg in "$@"; do
        case "$AGENT" in
            claude)
                if [[ "$arg" == "--resume" || "$arg" == "-r" ]]; then
                    user_has_resume=true
                fi
                ;;
            codex)
                if [[ "$arg" == "resume" ]]; then
                    user_has_resume=true
                fi
                ;;
            opencode)
                if [[ "$arg" == "--continue" || "$arg" == "-c" || "$arg" == "--session" || "$arg" == "-s" ]]; then
                    user_has_resume=true
                fi
                ;;
        esac
        [[ "$user_has_resume" == "true" ]] && break
    done

    set +e
    if [[ $# -gt 0 ]]; then
        case "$1" in
            claude|codex|opencode)
                if [[ "$user_has_resume" == "false" && ${#RESUME_ARGS[@]} -gt 0 ]]; then
                    "$@" "${RESUME_ARGS[@]}"
                else
                    "$@"
                fi
                ;;
            *)
                if [[ "$user_has_resume" == "false" && ${#RESUME_ARGS[@]} -gt 0 ]]; then
                    "$AGENT" "$@" "${RESUME_ARGS[@]}"
                else
                    "$AGENT" "$@"
                fi
                ;;
        esac
    else
        if [[ ${#RESUME_ARGS[@]} -gt 0 ]]; then
            "$AGENT" "${RESUME_ARGS[@]}"
        else
            "$AGENT"
        fi
    fi
    local code=$?

    capture_resume_token

    exit "$code"
}

setup_git_credential_helper() {
    # If gh is installed, configure git to use gh as the HTTPS credential helper.
    # Skip when ~/.gitconfig is read-only (e.g. mounted from host via FullGitSupport)
    # since the host config already has the user's preferred credential helpers.
    command -v gh >/dev/null 2>&1 || return 0
    [[ -w "$HOME/.gitconfig" ]] || [[ ! -f "$HOME/.gitconfig" ]] || return 0

    git config --global credential."https://github.com".helper '!gh auth git-credential' 2>/dev/null || true
    git config --global credential."https://gist.github.com".helper '!gh auth git-credential' 2>/dev/null || true
}

setup_ssh_proxy_tunnel() {
    # When the firewall is active (http_proxy set), configure SSH to tunnel
    # through the Squid HTTP proxy. SSH normally uses port 22 which Squid
    # blocks (CONNECT only on SSL_ports/443). Major git hosts offer SSH on
    # port 443:
    #   - github.com    → ssh.github.com:443
    #   - gitlab.com    → altssh.gitlab.com:443
    #   - bitbucket.org → altssh.bitbucket.org:443
    #
    # This runs regardless of SSH_AUTH_SOCK — even without agent forwarding,
    # SSH needs proxy routing to reach git hosts through the firewall.
    # Without this config, SSH fails with DNS resolution errors on the
    # isolated internal network.
    #
    # socat's PROXY address type speaks HTTP CONNECT, tunnelling the SSH
    # session through Squid on the allowed port.
    [[ -z "${http_proxy:-}" ]] && return 0
    command -v socat >/dev/null 2>&1 || return 0

    # Parse proxy host and port from http_proxy (e.g. http://172.18.0.2:3128).
    local proxy_url="${http_proxy#http://}"
    proxy_url="${proxy_url#https://}"
    proxy_url="${proxy_url%%/*}"
    local proxy_host="${proxy_url%%:*}"
    local proxy_port="${proxy_url##*:}"
    [[ -z "$proxy_host" ]] && return 0
    # If no port separator was found, proxy_port == proxy_host; default to 3128.
    [[ "$proxy_port" == "$proxy_host" ]] && proxy_port="3128"

    mkdir -p "$HOME/.ssh"
    chmod 700 "$HOME/.ssh"

    # Pin known SSH host keys for major git hosts (published by each provider).
    # Format: [hostname]:port key-type base64-key
    cat > "$HOME/.ssh/known_hosts" <<'KNOWNEOF'
[ssh.github.com]:443 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl
[ssh.github.com]:443 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=
[ssh.github.com]:443 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiphnt+VTTvDP6mHBL9j1aNUkY4Ue1gvwnGLVlOhGeYrnZaMgRK6+PKCUXaDbC7qtbW8gIkhL7aGCsOr/C56SJMy/BCZfxd1nWzAOxSDPgVsmerOBYfNqltV9/hWCqBywINIR+5dIg6JTJ72pcEpEjcYgXkE2YEFXV1JHnsKgbLWNlhScqb2UmyRkQyytRLtL+38TGxkxCflmO+5Z8CSSNY7GidjMIZ7Q4zMjA2n1nGrlTDkzwDCsw+wqFPGQA179cnfGWOWRVruj16z6XyvxvjJwbz0wQZ75XK5tKSb7FNyeIEs4TT4jk+S4dhPeAUC5y+bDYirYgM4GC7uEnztnZyaVWQ7B381AK4Qdrwt51ZqExKbQpTUNn+EjqoTwvqNj4kqx5QUCI0ThS/YkOxJCXmPUWZbhjpCg56i+2aB6CmK2JGhn57K5mj0MNdBXA4/WnwH6XoPWJzK5Nyu2zB3nAZp+S5hpQs+p1vN1/wsjk=
[altssh.gitlab.com]:443 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAfuCHKVTjquxvt6CM6tdG4SLp1Btn/nOeHHE5UOzRdf
[altssh.gitlab.com]:443 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBFSMqzJeV9rUzU4kWitGjeR4PWSa29SPqJ1fVkhtj3Hw9xjLVXVYrU9QlYWrOLXBpQ6KWjbjTDTdDkoohFzgbEY=
[altssh.gitlab.com]:443 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCsj2bNKTBSpIYDEGk9KxsGh3mySTRgMtXL583qmBpzeQ+jqCMRgBqB98u3z++J1sKlXHWfM9dyhSevkMwSbhoR8XIq/U0tCNyokEi/ueaBMCvbcTHhO7FcwzY92WK4Yt0aGROY5qX2UKSeOvuP4D6TPqKF1onrSzH9bx9XUf2lEdWT/ia1NEKjunUqu1xOB/StKDHMoX4/OKyIzuS0q/T1zOATthvasJFoPrAjkohTyaDUz2LN5JoH839hViyEG82yB+MjcFV5MU3N1l1QL3cVUCh93xSaua1N85qivl+siMkPGbO5xR/En4iEY6K2XPASUEMaieWVNTRCtJ4S8H+9
[altssh.bitbucket.org]:443 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIIazEu89wgQZ4bqs3d63QSMzYVa0MuJ2e2gKTKqu+UUO
[altssh.bitbucket.org]:443 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBPIQmuzMBuKdWeF4+a2sjSSpBK0iqitSQ+5BM9KhpexuGt20JpTVM7u5BDZngncgrqDMbWdxMWWOGtZ9UgbqgZE=
[altssh.bitbucket.org]:443 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDQeJzhupRu0u0cdegZIa8e86EG2qOCsIsD1Xw0xSeiPDlCr7kq97NLmMbpKTX6Esc30NuoqEEHCuc7yWtwp8dI76EEEB1VqY9QJq6vk+aySyboD5QF61I/1WeTwu+deCbgKMGbUijeXhtfbxSxm6JwGrXrhBdofTsbKRUsrN1WoNgUa8uqN1Vx6WAJw1JHPhglEGGHea6QICwJOAr/6mrui/oB7pkaWKHj3z7d1IC4KWLtY47elvjbaTlkN04Kc/5LFEirorGYVbt15kAUlqGM65pk6ZBxtaO3+30LVlORZkxOh+LKL/BvbZ/iRNhItLqNyieoQj/uh/7Iv4uyH/cV/0b4WDSd3DptigWq84lJubb9t/DnZlrJazxyDCulTmKdOR7vs9gMTo+uoIrPSb8ScTtvw65+odKAlBj59dhnVp9zd7QUojOpXlL62Aw56U4oO+FALuevvMjiWeavKhJqlR7i5n9srYcrNV7ttmDw7kf/97P5zauIhxcjX+xHv4M=
KNOWNEOF
    chmod 600 "$HOME/.ssh/known_hosts"

    cat > "$HOME/.ssh/config" <<SSHEOF
# ExitBox: SSH proxy tunneling through firewall.
# Auto-generated on container start — do not edit.

Host github.com
    Hostname ssh.github.com
    Port 443
    User git
    StrictHostKeyChecking yes
    ProxyCommand socat - PROXY:${proxy_host}:%h:%p,proxyport=${proxy_port}

Host gitlab.com
    Hostname altssh.gitlab.com
    Port 443
    User git
    StrictHostKeyChecking yes
    ProxyCommand socat - PROXY:${proxy_host}:%h:%p,proxyport=${proxy_port}

Host bitbucket.org
    Hostname altssh.bitbucket.org
    Port 443
    User git
    StrictHostKeyChecking yes
    ProxyCommand socat - PROXY:${proxy_host}:%h:%p,proxyport=${proxy_port}
SSHEOF
    chmod 600 "$HOME/.ssh/config"
}

setup_rtk() {
    # RTK token-optimized CLI wrappers — gated by EXITBOX_RTK=true.
    [[ "${EXITBOX_RTK:-}" != "true" ]] && return 0
    command -v rtk >/dev/null 2>&1 || return 0

    # For Claude: install PreToolUse hook to auto-rewrite commands to rtk equivalents.
    if [[ "${AGENT:-}" == "claude" ]]; then
        rtk init -g --hook-only --auto-patch 2>/dev/null || true
    fi
}

# ============================================================================
# AGENT DETECTION
# ============================================================================

AGENT="${EXITBOX_AGENT:-}"

if [[ -z "$AGENT" ]]; then
    if command -v claude >/dev/null 2>&1; then
        AGENT="claude"
    elif command -v codex >/dev/null 2>&1; then
        AGENT="codex"
    elif command -v opencode >/dev/null 2>&1; then
        AGENT="opencode"
    fi
fi

if [[ "${1:-}" == "__switch-workspace" ]]; then
    shift
    workspace_switch_menu
    exit 0
fi

if [[ "${1:-}" == "__workspace-menu" ]]; then
    shift
    workspace_switch_menu
    exit 0
fi

if [[ "${1:-}" == "__session-menu" ]]; then
    shift
    session_switch_menu
    exit 0
fi

if [[ "${1:-}" == "__smart-menu" ]]; then
    shift
    session_switch_menu
    exit 0
fi

if [[ -n "$AGENT" ]] && ! command -v "$AGENT" >/dev/null 2>&1; then
    echo "[ERROR] Agent '$AGENT' not found on PATH. The install likely failed during image build." >&2
    echo "[ERROR] Rebuild the agent image and check installer output." >&2
    exit 127
fi

# ============================================================================
# SANDBOX INSTRUCTIONS
# ============================================================================

SANDBOX_INSTRUCTIONS="<!-- BEGIN-EXITBOX-SANDBOX -->
# ExitBox Sandbox Environment

You are running inside an ExitBox sandboxed container. Important constraints:

- You CANNOT run container runtimes (docker, podman, nerdctl, etc.) inside this container.
- You CANNOT manage containers, images, volumes, or networks from within this environment.
- Do NOT attempt to debug issues by running docker/podman commands - they are not available.
- You CANNOT install packages. Do NOT run \`apk add\`, \`apt-get install\`, \`pip install\`,
  \`npm install -g\`, \`cargo install\`, or any other system-level package manager commands.
  You do not have permission and they will fail. All tools and packages are pre-installed
  at image build time by the host user. If you need a tool that is not available, inform
  the user and suggest they add it via \`exitbox setup\` or \`--tools\` flag on the host.
- WORKSPACE: The project codebase is ALWAYS mounted at /workspace. This is your ONLY
  working directory. You CANNOT access files, directories, or paths outside of /workspace.
  All file operations (read, write, search, git) must be within /workspace.
  Do NOT attempt to access /home, /etc, /var, or any other system path for project files.
- Network access is filtered through a firewall proxy. Only allowlisted domains are reachable.
- You are running as a non-root user with limited capabilities (no-new-privileges, all caps dropped).
- If you encounter permission errors or network issues, they are likely due to sandbox restrictions.
- IMPORTANT - Domain access requests: When ANY network request fails due to the firewall
  (HTTP 403 from proxy, connection refused, SSL errors, timeouts to non-allowlisted hosts),
  you MUST ask the user whether they want to allow access to that domain.
  If the user agrees, run \`exitbox-allow <domain>\` to request access.
  The host user will then be prompted a second time on the host terminal to confirm.
  Wait for the result before proceeding.
  If approved, retry the original request. If denied, inform the user and do not retry.
  Extract the domain from the failing URL and request it.
  Examples:
    exitbox-allow registry.npmjs.org
    exitbox-allow api.github.com
    exitbox-allow bunny.net
- SENSITIVE DATA: When any command output, log, or file content contains sensitive
  information (passwords, API keys, tokens, secrets, credentials, private keys),
  you MUST replace the actual values with \`<redacted>\` before displaying them to the
  user. NEVER show raw secret values in your responses, tool outputs, or summaries.
  Examples: \`Authorization: Bearer <redacted>\`, \`password: <redacted>\`,
  \`API_KEY=<redacted>\`. This applies to ALL contexts — code output, logs, configs, etc.
- Focus on writing, testing, and debugging code within /workspace. That is your scope.
<!-- END-EXITBOX-SANDBOX -->
"

# Append vault-specific instructions when vault is enabled.
if [[ "${EXITBOX_VAULT_ENABLED:-}" == "true" ]]; then
    if [[ "${EXITBOX_VAULT_READONLY:-}" == "true" ]]; then
        SANDBOX_INSTRUCTIONS="${SANDBOX_INSTRUCTIONS}
<!-- BEGIN-EXITBOX-VAULT -->
# Vault-Secured Secrets (Read-Only)

Encrypted vault (AES-256 + Argon2id) for secret management. All \`.env\` files
are masked — secrets are ONLY accessible through vault IPC commands.

This vault is read-only. You cannot store new secrets. Ask the host user to add
secrets via \`exitbox vault set\` on the host.

## Commands

\`\`\`bash
exitbox-vault list                    # List key names
exitbox-vault get <KEY>               # Get a secret value (stdout)
exitbox-vault env                     # Print all KEY=VALUE pairs
\`\`\`

## Rules — MANDATORY

1. **Use secrets via variables only.** Fetch into a shell variable, use inline:
   \`\`\`bash
   TOKEN=\$(exitbox-vault get MY_TOKEN)
   curl -H \"Authorization: Bearer \$TOKEN\" https://api.example.com
   \`\`\`
   When showing commands to the user, ALWAYS redact:
   \`curl -H \"Authorization: Bearer <redacted>\" ...\`

2. **ALWAYS redact command output.** When you have used \`exitbox-vault get\` in
   a session, you MUST assume ANY subsequent command output could contain the
   secret. NEVER run bare commands that print to stdout. ALWAYS capture output
   into a variable and redact ALL vault secrets before displaying:
   \`\`\`bash
   TOKEN=\$(exitbox-vault get MY_TOKEN)
   RESP=\$(curl -s -H \"Authorization: Bearer \$TOKEN\" http://example.com 2>&1)
   echo \"\$RESP\" | sed \"s/\$TOKEN/<redacted>/g\"
   \`\`\`
   This applies to curl, wget, API calls, server responses, logs, and ANY
   command whose output you have not personally verified is secret-free.

3. **Never expose secrets.** NEVER print, log, echo, inline, or display secret
   values anywhere — tool args, tool output, code, comments, commits, or response
   text. Always show \`<redacted>\`. Use \`\$VAR\` expansion, never literal values.

4. **Never persist secrets.** NEVER commit secrets to version control. Never
   write secrets to files on disk (no temp files, no .env copies, no config files).

5. **Fetch, don't ask.** When the user says \"use my API key\", fetch it via
   \`exitbox-vault get <KEY>\`, don't ask them to paste it.

6. **When in doubt, redact.** If unsure whether a value is sensitive, treat it
   as sensitive.

The host user will see an approval popup for each vault read. Wait for
approval before proceeding. If denied, inform the user and do not retry.
<!-- END-EXITBOX-VAULT -->
"
    else
        SANDBOX_INSTRUCTIONS="${SANDBOX_INSTRUCTIONS}
<!-- BEGIN-EXITBOX-VAULT -->
# Vault-Secured Secrets

Encrypted vault (AES-256 + Argon2id) for secret management. All \`.env\` files
are masked — secrets are ONLY accessible through vault IPC commands.

## Commands

\`\`\`bash
exitbox-vault list                    # List key names
exitbox-vault get <KEY>               # Get a secret value (stdout)
exitbox-vault set <KEY> <VALUE>       # Store a secret (host approval required)
exitbox-vault env                     # Print all KEY=VALUE pairs
\`\`\`

## Rules — MANDATORY

1. **Ask before storing.** When you detect a secret or are asked to generate one,
   ask the user for a key name FIRST. NEVER guess a default name. WAIT for their
   response before running \`exitbox-vault set\`.

2. **Generate secrets safely.** NEVER run a command that prints a secret to stdout.
   Generate and store in one step:
   \`\`\`bash
   exitbox-vault set <KEY> \"\$(python3 -c \"import secrets; print(secrets.token_urlsafe(32))\")\"
   \`\`\`

3. **Use secrets via variables only.** Fetch into a shell variable, use inline:
   \`\`\`bash
   TOKEN=\$(exitbox-vault get MY_TOKEN)
   curl -H \"Authorization: Bearer \$TOKEN\" https://api.example.com
   \`\`\`
   When showing commands to the user, ALWAYS redact:
   \`curl -H \"Authorization: Bearer <redacted>\" ...\`

4. **ALWAYS redact command output.** When you have used \`exitbox-vault get\` in
   a session, you MUST assume ANY subsequent command output could contain the
   secret. NEVER run bare commands that print to stdout. ALWAYS capture output
   into a variable and redact ALL vault secrets before displaying:
   \`\`\`bash
   TOKEN=\$(exitbox-vault get MY_TOKEN)
   RESP=\$(curl -s -H \"Authorization: Bearer \$TOKEN\" http://example.com 2>&1)
   echo \"\$RESP\" | sed \"s/\$TOKEN/<redacted>/g\"
   \`\`\`
   This applies to curl, wget, API calls, server responses, logs, and ANY
   command whose output you have not personally verified is secret-free.

5. **Never expose secrets.** NEVER print, log, echo, inline, or display secret
   values anywhere — tool args, tool output, code, comments, commits, or response
   text. Always show \`<redacted>\`. Use \`\$VAR\` expansion, never literal values.

6. **Never persist secrets.** NEVER commit secrets to version control. Never
   write secrets to files on disk (no temp files, no .env copies, no config files).

7. **Fetch, don't ask.** When the user says \"use my API key\", fetch it via
   \`exitbox-vault get <KEY>\`, don't ask them to paste it.

8. **When in doubt, redact.** If unsure whether a value is sensitive, treat it
   as sensitive.

The host user will see an approval popup for each vault read/write. Wait for
approval before proceeding. If denied, inform the user and do not retry.
<!-- END-EXITBOX-VAULT -->
"
    fi
fi

# Append KV store instructions (always available when IPC is running).
KV_RULES="1. **NEVER store secrets in KV.** Passwords, API keys, tokens, credentials,
   private keys, and any other sensitive values MUST NOT be stored in KV.
   The KV store is NOT encrypted and has NO access-control prompts.

2. **KV is for metadata only.** Appropriate values: session names, resume
   tokens (opaque IDs, not secrets), UI preferences, feature flags, timestamps,
   project bookmarks. Inappropriate values: anything you would redact."

if [[ "${EXITBOX_VAULT_ENABLED:-}" == "true" ]]; then
    KV_RULES="1. **NEVER store secrets in KV.** Passwords, API keys, tokens, credentials,
   private keys, and any other sensitive values MUST go in the vault
   (\`exitbox-vault\`), NEVER in KV. The KV store is NOT encrypted and has
   NO access-control prompts. If in doubt, use the vault.

2. **KV is for metadata only.** Appropriate values: session names, resume
   tokens (opaque IDs, not secrets), UI preferences, feature flags, timestamps,
   project bookmarks. Inappropriate values: anything you would redact.

3. **Do not duplicate vault data.** Never copy a vault secret into KV for
   convenience. Always read secrets from the vault at point of use."
fi

SANDBOX_INSTRUCTIONS="${SANDBOX_INSTRUCTIONS}
<!-- BEGIN-EXITBOX-KV -->
# KV Store for Session Data

A key-value store (\`exitbox-kv\`) is available for persisting non-sensitive
session metadata (session names, resume tokens, preferences, bookmarks).

## Commands

\`\`\`bash
exitbox-kv get <KEY>              # Get a value (stdout, exit 1 if missing)
exitbox-kv set <KEY> <VALUE>      # Store a value
exitbox-kv delete <KEY>           # Remove a key
exitbox-kv list [PREFIX]          # List matching keys, one per line
\`\`\`

## Rules — MANDATORY

${KV_RULES}
<!-- END-EXITBOX-KV -->
"

# Append rtk instructions when rtk support is enabled.
if [[ "${EXITBOX_RTK:-}" == "true" ]] && command -v rtk >/dev/null 2>&1; then
    SANDBOX_INSTRUCTIONS="${SANDBOX_INSTRUCTIONS}
<!-- BEGIN-EXITBOX-RTK -->
# RTK (Rust Token Killer) - Token-Optimized Commands

## Golden Rule

**Always prefix commands with \`rtk\`**. If RTK has a dedicated filter, it uses it. If not, it passes through unchanged. This means RTK is always safe to use.

**Important**: Even in command chains with \`&&\`, use \`rtk\`:
\`\`\`bash
# Wrong
git add . && git commit -m \"msg\" && git push

# Correct
rtk git add . && rtk git commit -m \"msg\" && rtk git push
\`\`\`

## RTK Commands by Workflow

### Build & Compile (80-90% savings)
\`\`\`bash
rtk cargo build         # Cargo build output
rtk cargo check         # Cargo check output
rtk cargo clippy        # Clippy warnings grouped by file (80%)
rtk tsc                 # TypeScript errors grouped by file/code (83%)
rtk lint                # ESLint/Biome violations grouped (84%)
rtk prettier --check    # Files needing format only (70%)
rtk next build          # Next.js build with route metrics (87%)
\`\`\`

### Test (90-99% savings)
\`\`\`bash
rtk cargo test          # Cargo test failures only (90%)
rtk vitest run          # Vitest failures only (99.5%)
rtk playwright test     # Playwright failures only (94%)
rtk test <cmd>          # Generic test wrapper - failures only
\`\`\`

### Git (59-80% savings)
\`\`\`bash
rtk git status          # Compact status
rtk git log             # Compact log (works with all git flags)
rtk git diff            # Compact diff (80%)
rtk git show            # Compact show (80%)
rtk git add             # Ultra-compact confirmations (59%)
rtk git commit          # Ultra-compact confirmations (59%)
rtk git push            # Ultra-compact confirmations
rtk git pull            # Ultra-compact confirmations
rtk git branch          # Compact branch list
rtk git fetch           # Compact fetch
rtk git stash           # Compact stash
rtk git worktree        # Compact worktree
\`\`\`

Note: Git passthrough works for ALL subcommands, even those not explicitly listed.

### GitHub (26-87% savings)
\`\`\`bash
rtk gh pr view <num>    # Compact PR view (87%)
rtk gh pr checks        # Compact PR checks (79%)
rtk gh run list         # Compact workflow runs (82%)
rtk gh issue list       # Compact issue list (80%)
rtk gh api              # Compact API responses (26%)
\`\`\`

### JavaScript/TypeScript Tooling (70-90% savings)
\`\`\`bash
rtk pnpm list           # Compact dependency tree (70%)
rtk pnpm outdated       # Compact outdated packages (80%)
rtk pnpm install        # Compact install output (90%)
rtk npm run <script>    # Compact npm script output
rtk npx <cmd>           # Compact npx command output
rtk prisma              # Prisma without ASCII art (88%)
\`\`\`

### Files & Search (60-75% savings)
\`\`\`bash
rtk ls <path>           # Tree format, compact (65%)
rtk read <file>         # Code reading with filtering (60%)
rtk grep <pattern>      # Search grouped by file (75%)
rtk find <pattern>      # Find grouped by directory (70%)
\`\`\`

### Analysis & Debug (70-90% savings)
\`\`\`bash
rtk err <cmd>           # Filter errors only from any command
rtk log <file>          # Deduplicated logs with counts
rtk json <file>         # JSON structure without values
rtk deps                # Dependency overview
rtk env                 # Environment variables compact
rtk summary <cmd>       # Smart summary of command output
rtk diff                # Ultra-compact diffs
\`\`\`

### Infrastructure (85% savings)
\`\`\`bash
rtk docker ps           # Compact container list
rtk docker images       # Compact image list
rtk docker logs <c>     # Deduplicated logs
rtk kubectl get         # Compact resource list
rtk kubectl logs        # Deduplicated pod logs
\`\`\`

### Network (65-70% savings)
\`\`\`bash
rtk curl <url>          # Compact HTTP responses (70%)
rtk wget <url>          # Compact download output (65%)
\`\`\`

### Go Tooling
\`\`\`bash
rtk go test             # Go test failures only
rtk go build            # Go build errors only
rtk go vet              # Go vet output
rtk golangci-lint run   # Linter output
\`\`\`

### Python Tooling
\`\`\`bash
rtk pytest              # Pytest failures only
rtk ruff <cmd>          # Ruff linter output
rtk pip <cmd>           # Pip install/list output
\`\`\`

### Meta Commands
\`\`\`bash
rtk gain                # View token savings statistics
rtk gain --history      # View command history with savings
rtk discover            # Analyze Claude Code sessions for missed RTK usage
rtk proxy <cmd>         # Run command without filtering (for debugging)
\`\`\`

## Token Savings Overview

| Category | Commands | Typical Savings |
|----------|----------|-----------------|
| Tests | vitest, playwright, cargo test | 90-99% |
| Build | next, tsc, lint, prettier | 70-87% |
| Git | status, log, diff, add, commit | 59-80% |
| GitHub | gh pr, gh run, gh issue | 26-87% |
| Package Managers | pnpm, npm, npx | 70-90% |
| Files | ls, read, grep, find | 60-75% |
| Infrastructure | docker, kubectl | 85% |
| Network | curl, wget | 65-70% |

Overall average: **60-90% token reduction** on common development operations.
<!-- END-EXITBOX-RTK -->
"
fi

inject_sandbox_instructions() {
    local target=""
    case "$AGENT" in
        claude)
            target="$HOME/.claude/CLAUDE.md"
            mkdir -p "$HOME/.claude"
            ;;
        codex)
            target="$HOME/.codex/AGENTS.md"
            mkdir -p "$HOME/.codex"
            ;;
        opencode)
            target="$HOME/.config/opencode/AGENTS.md"
            mkdir -p "$HOME/.config/opencode"
            ;;
    esac

    if [[ -z "$target" ]]; then
        return
    fi

    # Build the instruction file from two sources:
    #   1. User's agents.md (workspace-level, never touched by ExitBox)
    #   2. ExitBox sandbox instructions (auto-generated)
    #
    # The user's agents.md lives one level above the agent dir so the same
    # instructions apply to all agents in the workspace:
    #   /home/user/.exitbox-config/profiles/global/<workspace>/agents.md
    local user_agents_md=""
    local ws_root="${GLOBAL_WORKSPACE_ROOT}/${EXITBOX_WORKSPACE_NAME:-default}"
    if [[ -f "${ws_root}/agents.md" ]]; then
        user_agents_md="${ws_root}/agents.md"
    fi

    # Write the combined file (always regenerated on container start).
    {
        if [[ -n "$user_agents_md" ]]; then
            cat "$user_agents_md"
            printf '\n\n'
        fi
        printf '%s' "$SANDBOX_INSTRUCTIONS"
    } > "$target"
}

# ============================================================================
# RUN AGENT
# ============================================================================

cd "$WORKSPACE"

if [[ "$AGENT" == "codex" ]]; then
    start_codex_callback_relay
fi
start_ide_relay
setup_git_credential_helper
setup_ssh_proxy_tunnel
setup_rtk
trap 'cleanup_relay; cleanup_ide_relay' EXIT INT TERM

if [[ "${1:-}" == "__agent-loop" ]]; then
    shift
    tmux bind-key -n "$KB_WORKSPACE_MENU" run-shell 'tmux display-popup -E "EXITBOX_PARENT_PANE=#{pane_id} /usr/local/bin/docker-entrypoint __workspace-menu"' 2>/dev/null || true
    tmux bind-key -n "$KB_SESSION_MENU" run-shell 'tmux display-popup -E "EXITBOX_PARENT_PANE=#{pane_id} /usr/local/bin/docker-entrypoint __session-menu"' 2>/dev/null || true
    run_agent_loop "$@"
    exit $?
fi

if [[ $# -eq 0 && -n "$AGENT" && -z "${TMUX:-}" && -t 0 && -t 1 ]] && command -v tmux >/dev/null 2>&1; then
    # Fall back to a widely-supported TERM if the host terminal's terminfo
    # is not available inside the container (e.g. xterm-kitty, alacritty).
    if ! infocmp "$TERM" >/dev/null 2>&1; then
        export TERM="xterm-256color"
    fi
    TMUX_CONF="$(write_tmux_conf)"
    tmux -f "$TMUX_CONF" new-session -A -s "exitbox-${AGENT}" "/usr/local/bin/docker-entrypoint __agent-loop"
    TMUX_EXIT=$?

    # Show resume status after tmux exits (visible on the host terminal).
    session_name="$(effective_session_name)"
    session_dir="$(session_dir_for_name "$session_name")"
    resume_file="${session_dir}/.resume-token"
    if [[ -f "$resume_file" ]]; then
        saved_token="$(cat "$resume_file" 2>/dev/null)"
        if [[ -n "$saved_token" ]]; then
            echo ""
            resume_cmd="exitbox run ${AGENT}"
            if [[ -n "${EXITBOX_WORKSPACE_NAME:-}" && "${EXITBOX_WORKSPACE_NAME}" != "default" ]]; then
                resume_cmd="${resume_cmd} --workspace ${EXITBOX_WORKSPACE_NAME}"
            fi
            if [[ -n "$session_name" ]]; then
                resume_cmd="${resume_cmd} --name \"${session_name}\""
            fi
            echo "[INFO] Session saved (${session_name}). To resume: ${resume_cmd}"
        fi
    fi

    exit $TMUX_EXIT
fi

if [[ -n "$AGENT" ]]; then
    apply_active_workspace_links
    inject_sandbox_instructions
fi

# Debug: show what's available
if [[ "${VERBOSE:-false}" == "true" ]]; then
    echo "[DEBUG] PATH=$PATH" >&2
    echo "[DEBUG] HOME=$HOME" >&2
    echo "[DEBUG] AGENT=$AGENT" >&2
    echo "[DEBUG] ACTIVE_WORKSPACE=${EXITBOX_WORKSPACE_SCOPE}/${EXITBOX_WORKSPACE_NAME}" >&2
fi

run_agent_once "$@"
