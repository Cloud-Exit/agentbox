#!/bin/bash
# ==============================================================================
# Exitbox Docker Entrypoint
# Runs firewall setup, workspace selection, and executes agent
# ==============================================================================

set -e

WORKSPACE="/workspace"
CODEX_CALLBACK_PORT="1455"
CODEX_RELAY_PORT="2455"
RELAY_PID=""
WORKSPACE_SWITCH_FILE="/workspace/.exitbox/workspace-switch"
SESSION_ACTION_FILE="/workspace/.exitbox/session-action"
GLOBAL_CONFIG_FILE="/home/user/.exitbox-config/config.yaml"
GLOBAL_WORKSPACE_ROOT="/home/user/.exitbox-config/profiles/global"
# Save the workspace that was bind-mounted at container start (for isolation detection).
EXITBOX_MOUNTED_WORKSPACE="${EXITBOX_WORKSPACE_NAME:-}"

agent_display_name() {
    case "$1" in
        claude)   echo "Claude Code" ;;
        codex)    echo "OpenAI Codex" ;;
        opencode) echo "OpenCode" ;;
        *)        echo "$1" ;;
    esac
}

parse_keybindings() {
    KB_WORKSPACE_MENU="C-M-p"
    KB_SESSION_MENU="C-M-s"
    if [[ -n "${EXITBOX_KEYBINDINGS:-}" ]]; then
        IFS=',' read -ra KB_PAIRS <<< "$EXITBOX_KEYBINDINGS"
        for pair in "${KB_PAIRS[@]}"; do
            key="${pair%%=*}"
            val="${pair#*=}"
            case "$key" in
                workspace_menu) KB_WORKSPACE_MENU="$val" ;;
                session_menu)   KB_SESSION_MENU="$val" ;;
            esac
        done
    fi
}

parse_keybindings

update_tmux_status() {
    local display ws_name ver
    display="$(agent_display_name "$AGENT")"
    ws_name="${EXITBOX_WORKSPACE_NAME:-default}"
    ver="${EXITBOX_VERSION:-dev}"
    tmux set -g status-left " ExitBox  ${display} " 2>/dev/null || true
    tmux set -g window-status-current-format " Workspace: ${ws_name} " 2>/dev/null || true
    tmux set -g status-right " ${ver}  ${KB_WORKSPACE_MENU}: workspaces  ${KB_SESSION_MENU}: sessions " 2>/dev/null || true
}

write_tmux_conf() {
    local conf="/tmp/exitbox-tmux.conf"
    local display ws_name ver
    display="$(agent_display_name "$AGENT")"
    ws_name="${EXITBOX_WORKSPACE_NAME:-default}"
    ver="${EXITBOX_VERSION:-dev}"

    cat > "$conf" <<TMUXEOF
# ExitBox tmux configuration
set -g default-terminal "xterm-256color"
set -g status-position top
set -g status-style "bg=colour236,fg=colour255"
set -g status-left " ExitBox  ${display} "
set -g status-left-length 80
set -g status-right " ${ver}  ${KB_WORKSPACE_MENU}: workspaces  ${KB_SESSION_MENU}: sessions "
set -g status-right-length 90
set -g status-justify centre
set -g window-status-format ""
set -g window-status-current-format " Workspace: ${ws_name} "
set -g mouse on
set -g history-limit 100000
set -g pane-border-style "fg=colour236"
set -g pane-active-border-style "fg=colour236"
set -g message-style "bg=colour236,fg=colour255"
TMUXEOF

    if [[ "${EXITBOX_STATUS_BAR:-true}" != "true" ]]; then
        echo "set -g status off" >> "$conf"
    fi
    echo "$conf"
}

cleanup_relay() {
    if [[ -n "$RELAY_PID" ]]; then
        kill "$RELAY_PID" >/dev/null 2>&1 || true
    fi
}

start_codex_callback_relay() {
    if ! command -v socat >/dev/null 2>&1; then
        echo "[WARN] socat not found; Codex OAuth callback relay disabled" >&2
        return 0
    fi

    # Relay container-reachable traffic on 2455 to Codex's localhost callback on 1455.
    socat "TCP-LISTEN:${CODEX_RELAY_PORT},bind=0.0.0.0,reuseaddr,fork" "TCP:127.0.0.1:${CODEX_CALLBACK_PORT}" >/tmp/codex-oauth-relay.log 2>&1 &
    RELAY_PID="$!"
}

ensure_workspace_files() {
    mkdir -p "$(dirname "$GLOBAL_CONFIG_FILE")"
    mkdir -p "$GLOBAL_WORKSPACE_ROOT"
    if [[ ! -f "$GLOBAL_CONFIG_FILE" ]]; then
        cat > "$GLOBAL_CONFIG_FILE" <<'EOF'
version: 1
workspaces:
  active: default
  items:
    - name: default
      development: []
agents:
  claude:
    enabled: true
  codex:
    enabled: true
  opencode:
    enabled: true
tools:
  user: []
settings:
  auto_update: false
  status_bar: true
  default_workspace: default
  default_flags:
    no_firewall: false
    read_only: false
    no_env: false
    auto_resume: false
EOF
    fi
}

workspace_entries() {
    local globals
    # Try new key first, fall back to old "profiles" key
    globals="$(yq -r '(.workspaces.items[]?.name // .profiles.items[]?.name) // ""' "$GLOBAL_CONFIG_FILE" 2>/dev/null | sed '/^$/d')"
    if [[ -z "$globals" ]]; then
        globals="$(yq -r '.profiles.items[]?.name // ""' "$GLOBAL_CONFIG_FILE" 2>/dev/null | sed '/^$/d')"
    fi
    local result=""
    while IFS= read -r name; do
        [[ -z "$name" ]] && continue
        # Skip the currently active workspace.
        [[ "$name" == "${EXITBOX_WORKSPACE_NAME:-}" ]] && continue
        local dir
        dir="$(NAME="$name" yq -r '(.workspaces.items[] | select(.name == strenv(NAME)) | .directory) // ""' "$GLOBAL_CONFIG_FILE" 2>/dev/null || true)"
        if [[ -n "$dir" ]]; then
            result="${result}directory:${name} [${dir}]"$'\n'
        else
            result="${result}global:${name}"$'\n'
        fi
    done <<< "$globals"
    printf '%s' "$result" | sed '/^$/d'
}

resolve_active_workspace() {
    local global_default global_active first_global

    # Check directory-scoped workspaces (new key only)
    local current_dir
    current_dir="$(pwd)"
    local dir_match
    dir_match="$(yq -r ".workspaces.items[] | select(.directory == \"${current_dir}\") | .name // \"\"" "$GLOBAL_CONFIG_FILE" 2>/dev/null | head -n1 || true)"
    if [[ -n "$dir_match" ]]; then
        echo "directory:${dir_match}"
        return 0
    fi

    # Try new key, fall back to old key
    global_default="$(yq -r '.settings.default_workspace // .settings.default_profile // ""' "$GLOBAL_CONFIG_FILE" 2>/dev/null || true)"
    if [[ -n "$global_default" ]]; then
        echo "global:${global_default}"
        return 0
    fi

    global_active="$(yq -r '.workspaces.active // .profiles.active // ""' "$GLOBAL_CONFIG_FILE" 2>/dev/null || true)"
    if [[ -n "$global_active" ]]; then
        echo "global:${global_active}"
        return 0
    fi

    first_global="$(yq -r '.workspaces.items[]?.name // ""' "$GLOBAL_CONFIG_FILE" 2>/dev/null | sed '/^$/d' | head -n1)"
    if [[ -z "$first_global" ]]; then
        first_global="$(yq -r '.profiles.items[]?.name // ""' "$GLOBAL_CONFIG_FILE" 2>/dev/null | sed '/^$/d' | head -n1)"
    fi
    if [[ -n "$first_global" ]]; then
        echo "global:${first_global}"
        return 0
    fi

    echo "global:default"
}

set_active_workspace() {
    local scope="$1"
    local name="$2"
    if [[ -z "$scope" || -z "$name" ]]; then
        return 1
    fi

    ensure_workspace_files

    # Write new keys
    NAME="$name" yq -i '.settings.default_workspace = strenv(NAME)' "$GLOBAL_CONFIG_FILE"
    NAME="$name" yq -i '.workspaces.active = strenv(NAME)' "$GLOBAL_CONFIG_FILE"
    # Also write old keys for backward compat with configs not yet migrated
    NAME="$name" yq -i '.settings.default_profile = strenv(NAME)' "$GLOBAL_CONFIG_FILE"
    NAME="$name" yq -i '.profiles.active = strenv(NAME)' "$GLOBAL_CONFIG_FILE"
    return 0
}

link_path() {
    local src="$1"
    local dst="$2"
    mkdir -p "$(dirname "$dst")"
    rm -rf "$dst"
    ln -s "$src" "$dst"
}

apply_active_workspace_links() {
    ensure_workspace_files

    local scope name workspace_root

    # If the Go host already specified a workspace (via --workspace flag or
    # env var), use it directly. Only resolve from config.yaml when unset
    # (e.g. after an in-container workspace switch via Ctrl+Alt+P).
    if [[ -n "${EXITBOX_WORKSPACE_NAME:-}" ]]; then
        scope="${EXITBOX_WORKSPACE_SCOPE:-global}"
        name="${EXITBOX_WORKSPACE_NAME}"
    else
        local resolved
        resolved="$(resolve_active_workspace)"
        scope="${resolved%%:*}"
        name="${resolved#*:}"
    fi

    export EXITBOX_WORKSPACE_SCOPE="$scope"
    export EXITBOX_WORKSPACE_NAME="$name"

    workspace_root="${GLOBAL_WORKSPACE_ROOT}/${name}/${AGENT}"

    # Credential isolation: only the workspace that was mounted at container
    # start has real data. If the user switched to a different workspace via
    # Ctrl+P, its directory is empty (not bind-mounted from host).
    if [[ -n "$EXITBOX_MOUNTED_WORKSPACE" && "$name" != "$EXITBOX_MOUNTED_WORKSPACE" ]]; then
        echo "" >&2
        echo "[NOTE] Switched to workspace '${name}', but this container was started with workspace '${EXITBOX_MOUNTED_WORKSPACE}'." >&2
        echo "[NOTE] Credentials for '${name}' are not available in this session." >&2
        echo "[NOTE] To use this workspace, exit and re-run:" >&2
        echo "[NOTE]   exitbox run --workspace ${name} ${AGENT}" >&2
        echo "" >&2
    fi

    mkdir -p "$workspace_root"

    case "$AGENT" in
        claude)
            mkdir -p "$workspace_root/.claude" "$workspace_root/.config"
            touch "$workspace_root/.claude.json"
            link_path "$workspace_root/.claude" "$HOME/.claude"
            link_path "$workspace_root/.claude.json" "$HOME/.claude.json"
            link_path "$workspace_root/.config" "$HOME/.config"
            ;;
        codex)
            mkdir -p "$workspace_root/.codex" "$workspace_root/.config/codex"
            link_path "$workspace_root/.codex" "$HOME/.codex"
            mkdir -p "$HOME/.config"
            link_path "$workspace_root/.config/codex" "$HOME/.config/codex"
            ;;
        opencode)
            mkdir -p "$workspace_root/.opencode" \
                     "$workspace_root/.config/opencode" \
                     "$workspace_root/.local/share/opencode" \
                     "$workspace_root/.local/state" \
                     "$workspace_root/.cache/opencode"
            link_path "$workspace_root/.opencode" "$HOME/.opencode"
            mkdir -p "$HOME/.config" "$HOME/.local/share" "$HOME/.local" "$HOME/.cache"
            link_path "$workspace_root/.config/opencode" "$HOME/.config/opencode"
            link_path "$workspace_root/.local/share/opencode" "$HOME/.local/share/opencode"
            link_path "$workspace_root/.local/state" "$HOME/.local/state"
            link_path "$workspace_root/.cache/opencode" "$HOME/.cache/opencode"
            ;;
    esac
}

default_session_name() {
    date +"%Y-%m-%d %H:%M:%S"
}

current_session_name() {
    echo "${EXITBOX_SESSION_NAME:-}"
}

effective_session_name() {
    local name
    name="$(current_session_name)"
    if [[ -z "$name" ]]; then
        name="$(default_session_name)"
    fi
    echo "$name"
}

project_resume_dir() {
    local resume_dir project_key
    resume_dir="${GLOBAL_WORKSPACE_ROOT}/${EXITBOX_WORKSPACE_NAME:-default}/${AGENT}"
    if [[ -n "${EXITBOX_PROJECT_KEY:-}" ]]; then
        project_key="${EXITBOX_PROJECT_KEY//[^a-zA-Z0-9._-]/_}"
        resume_dir="${resume_dir}/projects/${project_key}"
    fi
    echo "$resume_dir"
}

active_session_file() {
    echo "$(project_resume_dir)/.active-session"
}

set_active_session_name() {
    local name="$1"
    local file
    file="$(active_session_file)"
    mkdir -p "$(dirname "$file")"
    printf '%s' "$name" > "$file"
}

get_active_session_name() {
    local file
    file="$(active_session_file)"
    if [[ -f "$file" ]]; then
        cat "$file"
    fi
}

session_key_for_name() {
    local name="$1"
    local slug hash
    slug="$(printf '%s' "$name" | tr -c 'A-Za-z0-9._-' '_' | sed 's/^_\\+//; s/_\\+$//; s/_\\+/_/g')"
    if [[ -z "$slug" ]]; then
        slug="session"
    fi
    hash="$(printf '%s' "$name" | cksum | awk '{print $1}')"
    echo "${slug}_${hash}"
}

session_dir_for_name() {
    local name="$1"
    local key
    key="$(session_key_for_name "$name")"
    echo "$(project_resume_dir)/sessions/${key}"
}

ensure_named_session_dir() {
    local name="$1"
    local session_dir
    session_dir="$(session_dir_for_name "$name")"
    mkdir -p "$session_dir"
    printf '%s' "$name" > "${session_dir}/.name"
}

legacy_resume_file() {
    echo "$(project_resume_dir)/.resume-token"
}

session_entries() {
    local root
    root="$(project_resume_dir)/sessions"
    [[ -d "$root" ]] || return 0
    for session_dir in "$root"/*; do
        [[ -d "$session_dir" ]] || continue
        if [[ -f "$session_dir/.name" ]]; then
            cat "$session_dir/.name"
        fi
    done | sed '/^$/d' | awk '!seen[$0]++'
}

write_session_action() {
    local workspace="$1"
    local session_name="$2"
    local resume="${3:-true}"
    mkdir -p "$(dirname "$SESSION_ACTION_FILE")"
    {
        if [[ -n "$workspace" ]]; then
            printf 'workspace=%s\n' "$workspace"
        fi
        if [[ -n "$session_name" ]]; then
            printf 'session=%s\n' "$session_name"
        fi
        printf 'resume=%s\n' "$resume"
    } > "$SESSION_ACTION_FILE"
}

request_graceful_switch() {
    if [[ -n "${EXITBOX_PARENT_PANE:-}" ]]; then
        tmux send-keys -t "${EXITBOX_PARENT_PANE}" C-c >/dev/null 2>&1 || true
    fi
}

session_switch_menu() {
    ensure_workspace_files
    local current_session new_session choices choice
    current_session="$(effective_session_name)"
    new_session="$(default_session_name)"

    choices="${choices}${new_session}"$'\t'"new"$'\n'
    while IFS= read -r s; do
        [[ -z "$s" ]] && continue
        if [[ "$s" == "$current_session" ]]; then
            continue
        fi
        choices="${choices}${s}"$'\t'"existing"$'\n'
    done < <(session_entries)

    local header prompt rc target_session kind
    header="Enter: Switch session"
    prompt="Sessions > "

    set +e
    choice="$(printf '%s' "$choices" | sed '/^$/d' | fzf --height=45% --reverse --border --prompt="$prompt" --header="$header" --delimiter=$'\t' --with-nth=1)"
    rc=$?
    set -e
    if [[ $rc -ne 0 || -z "$choice" ]]; then
        exit 0
    fi

    target_session="$(printf '%s' "$choice" | awk -F'\t' '{print $1}')"
    kind="$(printf '%s' "$choice" | awk -F'\t' '{print $2}')"
    if [[ -z "$target_session" ]]; then
        exit 0
    fi
    if [[ "$kind" == "existing" && "$target_session" == "$current_session" ]]; then
        exit 0
    fi

    write_session_action "" "$target_session" "true"
    echo "Saving current session and switching to session '${target_session}'..."
    request_graceful_switch
    exit 0
}

workspace_switch_menu() {
    ensure_workspace_files
    local current_session choices choice
    current_session="$(effective_session_name)"

    while IFS= read -r w; do
        [[ -z "$w" ]] && continue
        choices="${choices}${w}"$'\n'
    done < <(workspace_entries)
    if [[ -z "$choices" ]]; then
        choices="workspace:none"
    fi

    local header prompt rc
    header="Enter: Switch workspace"
    prompt="Workspaces > "

    set +e
    choice="$(printf '%s' "$choices" | sed '/^$/d' | fzf --height=45% --reverse --border --prompt="$prompt" --header="$header")"
    rc=$?
    set -e
    if [[ $rc -ne 0 || -z "$choice" ]]; then
        exit 0
    fi

    if [[ "$choice" == "workspace:none" ]]; then
        exit 0
    fi

    local workspace_choice scope name
    workspace_choice="$choice"
    scope="${workspace_choice%%:*}"
    name="${workspace_choice#*:}"
    name="${name%% \[*}"
    if [[ "$name" == "${EXITBOX_WORKSPACE_NAME:-}" ]]; then
        exit 0
    fi

    set_active_workspace "$scope" "$name"
    write_session_action "$name" "$current_session" "true"
    echo "Saving current session and switching to workspace '${name}'..."
    request_graceful_switch
    exit 0
}

smart_switch_menu() {
    # Backward-compatible alias: open sessions menu.
    session_switch_menu
}

capture_resume_token() {
    # Always capture tokens so they are available for explicit resume later.
    local output
    output="$(tmux capture-pane -p -S -100 2>/dev/null || true)"
    local session_name token session_dir token_file
    session_name="$(effective_session_name)"
    ensure_named_session_dir "$session_name"
    set_active_session_name "$session_name"
    session_dir="$(session_dir_for_name "$session_name")"
    token_file="${session_dir}/.resume-token"

    local token=""
    case "$AGENT" in
        claude)
            # Match: claude --resume <token>  or  claude -r <token>
            if [[ -n "$output" ]]; then
                token="$(echo "$output" | grep -oE "${AGENT} (--resume|-r) [^ ]+" | tail -1 | awk '{print $NF}' || true)"
            fi
            ;;
        codex)
            # Codex auto-saves sessions to ~/.codex/sessions/; no token printed at exit
            token="last"
            ;;
        opencode)
            # OpenCode auto-saves sessions locally; no token printed at exit
            token="last"
            ;;
    esac

    if [[ -n "$token" ]]; then
        echo "$token" > "$token_file"
        # Keep a single-slot token as compatibility fallback for older logic.
        echo "$token" > "$(legacy_resume_file)"
    fi
}

build_resume_args() {
    # Session resume resolution (called from run_agent_loop):
    #
    # Priority order:
    #   1. Explicit token (EXITBOX_RESUME_TOKEN set) → use it directly.
    #   2. Auto-resume enabled (EXITBOX_AUTO_RESUME=true):
    #      a. EXITBOX_SESSION_NAME set → look up per-session .resume-token.
    #      b. EXITBOX_SESSION_NAME empty → load from .active-session, then
    #         look up per-session token with legacy single-slot fallback.
    #   3. Neither → no resume args, agent starts fresh.
    #
    # The legacy fallback (project-level .resume-token) is ONLY used when
    # the session name came from .active-session (backward compat for
    # pre-named-session data). Explicitly named sessions that have no
    # stored token are new and always start fresh.
    RESUME_ARGS=()
    local session_name session_dir session_file token legacy_file
    session_name="$(current_session_name)"

    # If an explicit token was passed via --resume <token>, use it directly.
    if [[ -n "${EXITBOX_RESUME_TOKEN:-}" ]]; then
        if [[ -z "$session_name" ]]; then
            session_name="$(effective_session_name)"
        fi
        ensure_named_session_dir "$session_name"
        set_active_session_name "$session_name"
        case "$AGENT" in
            claude)
                RESUME_ARGS=("--resume" "$EXITBOX_RESUME_TOKEN")
                ;;
            codex)
                RESUME_ARGS=("resume" "--last")
                ;;
            opencode)
                RESUME_ARGS=("--continue")
                ;;
        esac
        return
    fi

    # Without explicit token, only auto-resume if enabled (--resume flag or workspace switch).
    if [[ "${EXITBOX_AUTO_RESUME:-false}" != "true" ]]; then
        return
    fi

    # Track whether the session name was explicitly provided (via --name) or
    # loaded from .active-session. The legacy fallback should only apply in
    # the .active-session case — explicitly named new sessions must start fresh.
    local from_active=false
    if [[ -z "$session_name" ]]; then
        session_name="$(get_active_session_name)"
        if [[ -z "$session_name" ]]; then
            return
        fi
        EXITBOX_SESSION_NAME="$session_name"
        from_active=true
    fi

    ensure_named_session_dir "$session_name"
    set_active_session_name "$session_name"

    session_dir="$(session_dir_for_name "$session_name")"
    session_file="${session_dir}/.resume-token"
    token=""
    if [[ -f "$session_file" ]]; then
        token="$(cat "$session_file")"
    fi

    if [[ -z "$token" && "$from_active" == "true" ]]; then
        # Compatibility fallback for older single-slot sessions that predate
        # the per-session token storage. Only used when resuming via
        # .active-session (no explicit --name). Named sessions that have no
        # saved token are new and should start fresh.
        legacy_file="$(legacy_resume_file)"
        if [[ -f "$legacy_file" ]]; then
            token="$(cat "$legacy_file")"
            if [[ -n "$token" ]]; then
                echo "$token" > "$session_file"
            fi
        fi
    fi

    if [[ -n "$token" ]]; then
        case "$AGENT" in
            claude)
                RESUME_ARGS=("--resume" "$token")
                ;;
            codex)
                RESUME_ARGS=("resume" "--last")
                ;;
            opencode)
                RESUME_ARGS=("--continue")
                ;;
        esac
    fi
}

run_agent_once() {
    if [[ $# -gt 0 ]]; then
        case "$1" in
            claude|codex|opencode)
                exec "$@"
                ;;
            *)
                if [[ -n "$AGENT" ]]; then
                    exec "$AGENT" "$@"
                else
                    exec "$@"
                fi
                ;;
        esac
    else
        if [[ -n "$AGENT" ]]; then
            exec "$AGENT"
        else
            exec bash
        fi
    fi
}

run_agent_loop() {
    apply_active_workspace_links
    update_tmux_status
    if [[ -n "$AGENT" ]]; then
        inject_sandbox_instructions
    fi

    build_resume_args

    # Check if user already passed resume-related flags in their args
    local user_has_resume=false
    for arg in "$@"; do
        case "$AGENT" in
            claude)
                if [[ "$arg" == "--resume" || "$arg" == "-r" ]]; then
                    user_has_resume=true
                fi
                ;;
            codex)
                if [[ "$arg" == "resume" ]]; then
                    user_has_resume=true
                fi
                ;;
            opencode)
                if [[ "$arg" == "--continue" || "$arg" == "-c" || "$arg" == "--session" || "$arg" == "-s" ]]; then
                    user_has_resume=true
                fi
                ;;
        esac
        [[ "$user_has_resume" == "true" ]] && break
    done

    set +e
    if [[ $# -gt 0 ]]; then
        case "$1" in
            claude|codex|opencode)
                if [[ "$user_has_resume" == "false" && ${#RESUME_ARGS[@]} -gt 0 ]]; then
                    "$@" "${RESUME_ARGS[@]}"
                else
                    "$@"
                fi
                ;;
            *)
                if [[ "$user_has_resume" == "false" && ${#RESUME_ARGS[@]} -gt 0 ]]; then
                    "$AGENT" "$@" "${RESUME_ARGS[@]}"
                else
                    "$AGENT" "$@"
                fi
                ;;
        esac
    else
        if [[ ${#RESUME_ARGS[@]} -gt 0 ]]; then
            "$AGENT" "${RESUME_ARGS[@]}"
        else
            "$AGENT"
        fi
    fi
    local code=$?

    capture_resume_token

    exit "$code"
}

# ============================================================================
# AGENT DETECTION
# ============================================================================

AGENT="${EXITBOX_AGENT:-}"

if [[ -z "$AGENT" ]]; then
    if command -v claude >/dev/null 2>&1; then
        AGENT="claude"
    elif command -v codex >/dev/null 2>&1; then
        AGENT="codex"
    elif command -v opencode >/dev/null 2>&1; then
        AGENT="opencode"
    fi
fi

if [[ "${1:-}" == "__switch-workspace" ]]; then
    shift
    workspace_switch_menu
    exit 0
fi

if [[ "${1:-}" == "__workspace-menu" ]]; then
    shift
    workspace_switch_menu
    exit 0
fi

if [[ "${1:-}" == "__session-menu" ]]; then
    shift
    session_switch_menu
    exit 0
fi

if [[ "${1:-}" == "__smart-menu" ]]; then
    shift
    session_switch_menu
    exit 0
fi

if [[ -n "$AGENT" ]] && ! command -v "$AGENT" >/dev/null 2>&1; then
    echo "[ERROR] Agent '$AGENT' not found on PATH. The install likely failed during image build." >&2
    echo "[ERROR] Rebuild the agent image and check installer output." >&2
    exit 127
fi

# ============================================================================
# SANDBOX INSTRUCTIONS
# ============================================================================

SANDBOX_INSTRUCTIONS="<!-- BEGIN-EXITBOX-SANDBOX -->
# ExitBox Sandbox Environment

You are running inside an ExitBox sandboxed container. Important constraints:

- You CANNOT run container runtimes (docker, podman, nerdctl, etc.) inside this container.
- You CANNOT manage containers, images, volumes, or networks from within this environment.
- Do NOT attempt to debug issues by running docker/podman commands - they are not available.
- You CANNOT install packages. Do NOT run \`apk add\`, \`apt-get install\`, \`pip install\`,
  \`npm install -g\`, \`cargo install\`, or any other system-level package manager commands.
  You do not have permission and they will fail. All tools and packages are pre-installed
  at image build time by the host user. If you need a tool that is not available, inform
  the user and suggest they add it via \`exitbox setup\` or \`--tools\` flag on the host.
- WORKSPACE: The project codebase is ALWAYS mounted at /workspace. This is your ONLY
  working directory. You CANNOT access files, directories, or paths outside of /workspace.
  All file operations (read, write, search, git) must be within /workspace.
  Do NOT attempt to access /home, /etc, /var, or any other system path for project files.
- Network access is filtered through a firewall proxy. Only allowlisted domains are reachable.
- You are running as a non-root user with limited capabilities (no-new-privileges, all caps dropped).
- If you encounter permission errors or network issues, they are likely due to sandbox restrictions.
- IMPORTANT - Domain access requests: When ANY network request fails due to the firewall
  (HTTP 403 from proxy, connection refused, SSL errors, timeouts to non-allowlisted hosts),
  you MUST ask the user whether they want to allow access to that domain.
  If the user agrees, run \`exitbox-allow <domain>\` to request access.
  The host user will then be prompted a second time on the host terminal to confirm.
  Wait for the result before proceeding.
  If approved, retry the original request. If denied, inform the user and do not retry.
  Extract the domain from the failing URL and request it.
  Examples:
    exitbox-allow registry.npmjs.org
    exitbox-allow api.github.com
    exitbox-allow bunny.net
- SENSITIVE DATA: When any command output, log, or file content contains sensitive
  information (passwords, API keys, tokens, secrets, credentials, private keys),
  you MUST replace the actual values with \`<redacted>\` before displaying them to the
  user. NEVER show raw secret values in your responses, tool outputs, or summaries.
  Examples: \`Authorization: Bearer <redacted>\`, \`password: <redacted>\`,
  \`API_KEY=<redacted>\`. This applies to ALL contexts — code output, logs, configs, etc.
- Focus on writing, testing, and debugging code within /workspace. That is your scope.
<!-- END-EXITBOX-SANDBOX -->
"

# Append vault-specific instructions when vault is enabled.
if [[ "${EXITBOX_VAULT_ENABLED:-}" == "true" ]]; then
    if [[ "${EXITBOX_VAULT_READONLY:-}" == "true" ]]; then
        SANDBOX_INSTRUCTIONS="${SANDBOX_INSTRUCTIONS}
<!-- BEGIN-EXITBOX-VAULT -->
# Vault-Secured Secrets (Read-Only)

Encrypted vault (AES-256 + Argon2id) for secret management. All \`.env\` files
are masked — secrets are ONLY accessible through vault IPC commands.

This vault is read-only. You cannot store new secrets. Ask the host user to add
secrets via \`exitbox vault set\` on the host.

## Commands

\`\`\`bash
exitbox-vault list                    # List key names
exitbox-vault get <KEY>               # Get a secret value (stdout)
exitbox-vault env                     # Print all KEY=VALUE pairs
\`\`\`

## Rules — MANDATORY

1. **Use secrets via variables only.** Fetch into a shell variable, use inline:
   \`\`\`bash
   TOKEN=\$(exitbox-vault get MY_TOKEN)
   curl -H \"Authorization: Bearer \$TOKEN\" https://api.example.com
   \`\`\`
   When showing commands to the user, ALWAYS redact:
   \`curl -H \"Authorization: Bearer <redacted>\" ...\`

2. **ALWAYS redact command output.** When you have used \`exitbox-vault get\` in
   a session, you MUST assume ANY subsequent command output could contain the
   secret. NEVER run bare commands that print to stdout. ALWAYS capture output
   into a variable and redact ALL vault secrets before displaying:
   \`\`\`bash
   TOKEN=\$(exitbox-vault get MY_TOKEN)
   RESP=\$(curl -s -H \"Authorization: Bearer \$TOKEN\" http://example.com 2>&1)
   echo \"\$RESP\" | sed \"s/\$TOKEN/<redacted>/g\"
   \`\`\`
   This applies to curl, wget, API calls, server responses, logs, and ANY
   command whose output you have not personally verified is secret-free.

3. **Never expose secrets.** NEVER print, log, echo, inline, or display secret
   values anywhere — tool args, tool output, code, comments, commits, or response
   text. Always show \`<redacted>\`. Use \`\$VAR\` expansion, never literal values.

4. **Never persist secrets.** NEVER commit secrets to version control. Never
   write secrets to files on disk (no temp files, no .env copies, no config files).

5. **Fetch, don't ask.** When the user says \"use my API key\", fetch it via
   \`exitbox-vault get <KEY>\`, don't ask them to paste it.

6. **When in doubt, redact.** If unsure whether a value is sensitive, treat it
   as sensitive.

The host user will see an approval popup for each vault read. Wait for
approval before proceeding. If denied, inform the user and do not retry.
<!-- END-EXITBOX-VAULT -->
"
    else
        SANDBOX_INSTRUCTIONS="${SANDBOX_INSTRUCTIONS}
<!-- BEGIN-EXITBOX-VAULT -->
# Vault-Secured Secrets

Encrypted vault (AES-256 + Argon2id) for secret management. All \`.env\` files
are masked — secrets are ONLY accessible through vault IPC commands.

## Commands

\`\`\`bash
exitbox-vault list                    # List key names
exitbox-vault get <KEY>               # Get a secret value (stdout)
exitbox-vault set <KEY> <VALUE>       # Store a secret (host approval required)
exitbox-vault env                     # Print all KEY=VALUE pairs
\`\`\`

## Rules — MANDATORY

1. **Ask before storing.** When you detect a secret or are asked to generate one,
   ask the user for a key name FIRST. NEVER guess a default name. WAIT for their
   response before running \`exitbox-vault set\`.

2. **Generate secrets safely.** NEVER run a command that prints a secret to stdout.
   Generate and store in one step:
   \`\`\`bash
   exitbox-vault set <KEY> \"\$(python3 -c \"import secrets; print(secrets.token_urlsafe(32))\")\"
   \`\`\`

3. **Use secrets via variables only.** Fetch into a shell variable, use inline:
   \`\`\`bash
   TOKEN=\$(exitbox-vault get MY_TOKEN)
   curl -H \"Authorization: Bearer \$TOKEN\" https://api.example.com
   \`\`\`
   When showing commands to the user, ALWAYS redact:
   \`curl -H \"Authorization: Bearer <redacted>\" ...\`

4. **ALWAYS redact command output.** When you have used \`exitbox-vault get\` in
   a session, you MUST assume ANY subsequent command output could contain the
   secret. NEVER run bare commands that print to stdout. ALWAYS capture output
   into a variable and redact ALL vault secrets before displaying:
   \`\`\`bash
   TOKEN=\$(exitbox-vault get MY_TOKEN)
   RESP=\$(curl -s -H \"Authorization: Bearer \$TOKEN\" http://example.com 2>&1)
   echo \"\$RESP\" | sed \"s/\$TOKEN/<redacted>/g\"
   \`\`\`
   This applies to curl, wget, API calls, server responses, logs, and ANY
   command whose output you have not personally verified is secret-free.

5. **Never expose secrets.** NEVER print, log, echo, inline, or display secret
   values anywhere — tool args, tool output, code, comments, commits, or response
   text. Always show \`<redacted>\`. Use \`\$VAR\` expansion, never literal values.

6. **Never persist secrets.** NEVER commit secrets to version control. Never
   write secrets to files on disk (no temp files, no .env copies, no config files).

7. **Fetch, don't ask.** When the user says \"use my API key\", fetch it via
   \`exitbox-vault get <KEY>\`, don't ask them to paste it.

8. **When in doubt, redact.** If unsure whether a value is sensitive, treat it
   as sensitive.

The host user will see an approval popup for each vault read/write. Wait for
approval before proceeding. If denied, inform the user and do not retry.
<!-- END-EXITBOX-VAULT -->
"
    fi
fi

inject_sandbox_instructions() {
    local target=""
    case "$AGENT" in
        claude)
            target="$HOME/.claude/CLAUDE.md"
            mkdir -p "$HOME/.claude"
            ;;
        codex)
            target="$HOME/.codex/AGENTS.md"
            mkdir -p "$HOME/.codex"
            ;;
        opencode)
            target="$HOME/.config/opencode/AGENTS.md"
            mkdir -p "$HOME/.config/opencode"
            ;;
    esac

    if [[ -z "$target" ]]; then
        return
    fi

    if [[ -f "$target" ]]; then
        # Remove any existing sandbox block (new marker format or legacy).
        if grep -q "BEGIN-EXITBOX-SANDBOX" "$target" 2>/dev/null; then
            sed -i '/<!-- BEGIN-EXITBOX-SANDBOX -->/,/<!-- END-EXITBOX-SANDBOX -->/d' "$target"
        elif grep -q "# ExitBox Sandbox Environment" "$target" 2>/dev/null; then
            # Legacy format: remove from header through trailing blank lines.
            sed -i '/^# ExitBox Sandbox Environment$/,/^[[:space:]]*$/d' "$target"
        fi
        # Remove any existing vault blocks from previous runs.
        if grep -q "BEGIN-EXITBOX-VAULT" "$target" 2>/dev/null; then
            sed -i '/<!-- BEGIN-EXITBOX-VAULT -->/,/<!-- END-EXITBOX-VAULT -->/d' "$target"
        fi
        printf '\n%s' "$SANDBOX_INSTRUCTIONS" >> "$target"
    else
        printf '%s' "$SANDBOX_INSTRUCTIONS" > "$target"
    fi
}

# ============================================================================
# RUN AGENT
# ============================================================================

cd "$WORKSPACE"

if [[ "$AGENT" == "codex" ]]; then
    start_codex_callback_relay
    trap cleanup_relay EXIT INT TERM
fi

if [[ "${1:-}" == "__agent-loop" ]]; then
    shift
    tmux bind-key -n "$KB_WORKSPACE_MENU" run-shell 'tmux display-popup -E "EXITBOX_PARENT_PANE=#{pane_id} /usr/local/bin/docker-entrypoint __workspace-menu"' 2>/dev/null || true
    tmux bind-key -n "$KB_SESSION_MENU" run-shell 'tmux display-popup -E "EXITBOX_PARENT_PANE=#{pane_id} /usr/local/bin/docker-entrypoint __session-menu"' 2>/dev/null || true
    run_agent_loop "$@"
    exit $?
fi

if [[ $# -eq 0 && -n "$AGENT" && -z "${TMUX:-}" && -t 0 && -t 1 ]] && command -v tmux >/dev/null 2>&1; then
    # Fall back to a widely-supported TERM if the host terminal's terminfo
    # is not available inside the container (e.g. xterm-kitty, alacritty).
    if ! infocmp "$TERM" >/dev/null 2>&1; then
        export TERM="xterm-256color"
    fi
    TMUX_CONF="$(write_tmux_conf)"
    tmux -f "$TMUX_CONF" new-session -A -s "exitbox-${AGENT}" "/usr/local/bin/docker-entrypoint __agent-loop"
    TMUX_EXIT=$?

    # Show resume status after tmux exits (visible on the host terminal).
    session_name="$(effective_session_name)"
    session_dir="$(session_dir_for_name "$session_name")"
    resume_file="${session_dir}/.resume-token"
    if [[ -f "$resume_file" ]]; then
        saved_token="$(cat "$resume_file" 2>/dev/null)"
        if [[ -n "$saved_token" ]]; then
            echo ""
            resume_cmd="exitbox run ${AGENT}"
            if [[ -n "${EXITBOX_WORKSPACE_NAME:-}" && "${EXITBOX_WORKSPACE_NAME}" != "default" ]]; then
                resume_cmd="${resume_cmd} --workspace ${EXITBOX_WORKSPACE_NAME}"
            fi
            if [[ -n "$session_name" ]]; then
                resume_cmd="${resume_cmd} --name \"${session_name}\""
            fi
            echo "[INFO] Session saved (${session_name}). To resume: ${resume_cmd}"
        fi
    fi

    exit $TMUX_EXIT
fi

if [[ -n "$AGENT" ]]; then
    apply_active_workspace_links
    inject_sandbox_instructions
fi

# Debug: show what's available
if [[ "${VERBOSE:-false}" == "true" ]]; then
    echo "[DEBUG] PATH=$PATH" >&2
    echo "[DEBUG] HOME=$HOME" >&2
    echo "[DEBUG] AGENT=$AGENT" >&2
    echo "[DEBUG] ACTIVE_WORKSPACE=${EXITBOX_WORKSPACE_SCOPE}/${EXITBOX_WORKSPACE_NAME}" >&2
fi

run_agent_once "$@"
